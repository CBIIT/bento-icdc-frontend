schema {
    query: QueryType
}

type BreedCaseCount {
    breed: String
    cases: Int
}

type CaseDetail {
    program_acronym: String
    clinical_study_name: String
    clinical_study_designation: String
    arm: String
    ctep_treatment_assignment_code: String
    cohort_description: String
    case_id: String
    patient_id: String
    patient_first_name: String
    breed: String
    sex: String
    patient_age_at_enrollment: Float
    neutered_indicator: String
    weight: Float
    site_short_name: String
    date_of_registration: String
    patient_subgroup: String
    date_of_informed_consent: String
    initials: String
    disease_term: String
    stage_of_disease: String
    best_response: String
    date_of_diagnosis: String
    primary_disease_site: String
    histological_grade: String
    histology_cytopathology: String
}

type Link {
    text: String
    url: String
}

type StudyOfProgram {
    program_id: String
    clinical_study_id: String
    clinical_study_designation: String
    clinical_study_name: String
    clinical_study_description: String
    clinical_study_type: String
    accession_id: String
    study_disposition: String
    date_of_iacuc_approval: String
    dates_of_conduct: String
    numberOfCases: Int
    numberOfStudyFiles: Int,
    numberOfCaseFiles: Int,
    numberOfImageCollections: Int,
    numberOfPublications: Int,
    numberOfCRDCNodes: Int
    CRDCLinks: [Link]
}

type FileOverview2 {
    parent:String
    file_name: String
    file_type: String
    file_description: String
    file_format: String
    file_size: Float
    md5sum: String
    file_status: String
    uuid: String
    file_location: String
}

type CaseOverview {
    case_id: String
    program: String
    study_code: String
    study_type: String
    breed: String
    diagnosis: String
    stage_of_disease: String
    age: Float
    sex: String
    neutered_status: String
    data_types: [String]
    disease_site: String
    samples: [String]
    sample_list: [sample]
    files: [FileOverview2]
    file_formats: [String]
    demographic: demographic
    diagnosis_obj: diagnosis
}


type FilesOfCase{
    case_id: String
    parent:String
    file_name: String
    file_type: String
    file_description: String
    file_format: String
    file_size: Float
    md5sum: String
    file_status: String
    uuid: String
    file_location: String
}

type StudyDetail {
    study_code: String
    file_name: String
    file_type: String
    association: String
    description: String
    format: String
    size: Float
    MD5: String
}

type FileDetail {
    clinical_study_designation: String
    clinical_study_name: String
    arm: String
    cohort_description: String
    cohort_dose: String
    case_id: String
    breed: String
    weight: Float
    sex: String
    neutered_indicator: String
    patient_age_at_enrollment: Float
    disease_term: String
    stage_of_disease: String
    primary_disease_site: String
    concurrent_disease: Boolean
    concurrent_disease_type: String
    visit_date: String
    visit_number: String
    day_in_cycle: Int
    sample_id: String
    sample_type: String
    general_sample_pathology: String
    specific_sample_pathology: String
    sample_site: String
    date_of_sample_collection: String
    necropsy_sample: Boolean
    percentage_tumor: String
    percentage_stroma: Float
    comment: String
    file_name: String
    file_type: String
    file_description: String
    file_format: String
    file_size: Float
    md5sum: String
    file_location: String
    uuid: String
    acl: String
    GUID: String
    md5: String
    size: Float
    url: String
}

type FileInfo {
    GUID: String
    md5: String
    size: Float
    acl: String
    url: String
}

type StudyStat {
    study_code: String
    files: Int
    total_size_MB: Float
    cases: Int
    samples: Int
}

type FileInList {
    file_name: String
    file_type: String
    association: String
    file_description: String
    file_format: String
    file_size: Float
    case_id: String
    breed: String
    diagnosis: String
    study_code: String
    file_uuid: String
    md5sum: String
    sample_id: String
    individual_id: String
    sample_site: String
    physical_sample_type: String
    general_sample_pathology: String
    tumor_sample_origin: String
    summarized_sample_type: String
    specific_sample_pathology: String
    date_of_sample_collection: String
    tumor_grade: String
    sample_chronology: String
    percentage_tumor: String
    necropsy_sample: String
    sample_preservation: String
    comment: String
    patient_age_at_enrollment: String
    sex: String
    neutered_indicator: String
    weight: String
    weight_unit: String
    disease_term: String
    primary_disease_site: String
    stage_of_disease: String
    date_of_diagnosis: String
    histology_cytopathology: String
    histological_grade: String
    best_response: String
    pathology_report: String
    treatment_data: String
    follow_up_data: String
    concurrent_disease: String
    concurrent_disease_type: String
    cohort_description: String
    arm: String
    other_cases: [String]
}

type FileOverview {
    file_name: String
    file_type: String
    association: String
    file_description: String
    file_format: String
    file_size: Float
    case_id: String
    breed: String
    diagnosis: String
    study_code: String
    file_uuid: String
    sample_id: String
    sample_site: String
    physical_sample_type: String
    general_sample_pathology: String
    tumor_sample_origin: String
    summarized_sample_type: String
    specific_sample_pathology: String
    date_of_sample_collection: String
    tumor_grade: String
    sample_chronology: String
    percentage_tumor: String
    necropsy_sample: String
    sample_preservation: String
    comment: String
    individual_id: String
    patient_age_at_enrollment: String
    sex: String
    neutered_indicator: String
    weight: String
    primary_disease_site: String
    stage_of_disease: String
    date_of_diagnosis: String
    histology_cytopathology: String
    histological_grade: String
    best_response: String
    pathology_report: String
    treatment_data: String
    follow_up_data: String
    concurrent_disease: String
    concurrent_disease_type: String
    cohort_description: String
    arm: String
    other_cases: [String]
}

type SampleOverview {
    sample_id: String
    case_id: String
    breed: String
    diagnosis: String
    sample_site: String
    sample_type: String
    sample_pathology: String
    tumor_grade: String
    sample_chronology: String
    percentage_tumor: String
    necropsy_sample: String
    sample_preservation: String
    files: [String]
    physical_sample_type: String
    general_sample_pathology: String
    tumor_sample_origin: String
    comment: String
    individual_id: String
    other_cases: [String]
    patient_age_at_enrollment: String
    sex: String
    neutered_indicator: String
    weight: String
    primary_disease_site: String
    stage_of_disease: String
    date_of_diagnosis: String
    histology_cytopathology: String
    histological_grade: String
    best_response: String
    pathology_report: String
    treatment_data: String
    follow_up_data: String
    concurrent_disease: String
    concurrent_disease_type: String
    cohort_description: String
    arm: String
}

type CaseOverview2 {
    case_id: String
    study_code: String
    study_type: String
    cohort: String
    breed: String
    diagnosis: String
    stage_of_disease: String
    age: Float
    sex: String
    neutered_status: String
    weight: Float
    response_to_treatment: String
    disease_site: String
    files: [String]
    other_cases: [String]
    individual_id: String
    primary_disease_site: String
    date_of_diagnosis: String
    histology_cytopathology: String
    histological_grade: String
    pathology_report: String
    treatment_data: String
    follow_up_data: String
    concurrent_disease: String
    concurrent_disease_type: String
    arm: String
}

type GroupCount {
    group: String
    count: Int
    code: String
}

type MultiStudyCases {
    individualId: String
    caseIds: [String]
    sampleIds: [String]
    fileIds: [String]
    studyFileIds: [String]
}

type UnifiedCounts{
    numberOfStudies: Int
    numberOfCases: Int
    numberOfFiles: Int
    numberOfSamples: Int
    numberOfStudyFiles: Int
    numberOfPrograms: Int
    numberOfAliquots: Int
    volumeOfData: Float
}

type QueryType {
    "Version"
    schemaVersion: String @cypher(statement: "RETURN '2.0.0'")

    "Simple count"
    numberOfStudies: Int @cypher(statement: "MATCH (n:study) WHERE n.study_disposition = 'Unrestricted' RETURN  count (n)")
    numberOfCases: Int @cypher(statement: "MATCH (n:case) RETURN  count (n)")
    numberOfSamples:Int @cypher(statement: "MATCH (n:sample) RETURN  count (n)")
    numberOfFiles: Int @cypher(statement: "MATCH (n:file) RETURN  count (n)")
    numberOfStudyFiles: Int @cypher(statement: "MATCH (n:file)-->(sd:study) RETURN count (n)")
    numberOfPrograms: Int @cypher(statement: "MATCH (n:program) RETURN count (n)")
    numberOfAliquots: Int @cypher(statement: "MATCH (n:aliquot) return count(n)")
    volumeOfData: Float @cypher(statement: "MATCH (f:file) return sum(DISTINCT f.file_size)")
    volumeOfDataOfCase(case_id: String!): Float @cypher(statement: "MATCH (c:case{case_id: $case_id})-->(s:study) WITH s OPTIONAL MATCH (s)<--(f:file) WITH SUM(f.file_size) AS study_file_size OPTIONAL MATCH (c:case{case_id: $case_id})<-[*]-(f:file) with DISTINCT f, study_file_size RETURN SUM(f.file_size) + study_file_size")

    "Count with parameter"
    sampleCountOfStudy(study_code: String!): Int @cypher(statement: "MATCH (s:sample)-[*]->(sd:study) WHERE sd.clinical_study_designation = $study_code OR sd.accession_id = $study_code return count(DISTINCT(s))")
    fileCountOfStudy(study_code: String!): Int @cypher(statement: "MATCH (f:file)-[*]->(sd:study) WHERE sd.clinical_study_designation = $study_code OR sd.accession_id = $study_code return count(distinct(f))")
    fileCountOfStudyFiles(study_code: String!): Int @cypher(statement: "MATCH (f:file)-->(sd:study) WHERE sd.clinical_study_designation = $study_code OR sd.accession_id = $study_code return count(distinct(f))")
    aliquotCountOfStudy(study_code: String!): Int @cypher(statement: "MATCH (a:aliquot)-[*]->(sd:study) WHERE sd.clinical_study_designation = $study_code OR sd.accession_id = $study_code  return count(DISTINCT(a))")
    caseCountOfStudy(study_code: String!): Int @cypher(statement: "MATCH (c:case)-[*]->(sd:study) WHERE sd.clinical_study_designation = $study_code OR sd.accession_id = $study_code return count(distinct(c))")
    fileCountOfCase(case_id: String!): Int @cypher(statement: "MATCH (f:file)-[*]->(c:case {case_id: $case_id}) return count(DISTINCT(f))")
    studyFileCountOfCase(case_id: String!): Int @cypher(statement: "MATCH (c:case {case_id: $case_id}) OPTIONAL MATCH (c)-[:member_of]->(s:study) OPTIONAL MATCH (s)<--(f:file) return count(DISTINCT(f))")
    aliquotCountOfCase(case_id: String!): Int @cypher(statement: "MATCH (a:aliquot)-[*]->(c:case {case_id: $case_id}) return count(DISTINCT(a))")
    sampleCountOfProgram(program_id: String!): Int @cypher(statement: "MATCH (s:sample)-[*]->(:program {program_acronym: $program_id}) return count(DISTINCT(s))")
    fileCountOfProgram(program_id: String!): Int @cypher(statement: "MATCH (f:file)-[*]->(:program {program_acronym: $program_id}) return count(DISTINCT(f))")
    studyFileCountOfProgram(program_id: String!): Int @cypher(statement: "MATCH (s:study)-[*]->(:program {program_acronym: $program_id}) OPTIONAL MATCH (s) <-- (f:file) return count(DISTINCT(f))")
    aliquotCountOfProgram(program_id: String!): Int @cypher(statement: "MATCH (a:aliquot)-[*]->(:program {program_acronym: $program_id}) return count(DISTINCT(a))")
    studyCountOfProgram(program_id: String!): Int @cypher(statement: "MATCH (s:study)-[*]->(:program {program_acronym: $program_id}) WHERE s.study_disposition = 'Unrestricted' return count(DISTINCT(s))")
    caseCountOfProgram(program_id: String!): Int @cypher(statement: "MATCH (c:case)-[*]->(:program {program_acronym: $program_id}) return count(DISTINCT(c))")
    sampleCountOfCase(case_id: String!): Int @cypher(statement: "MATCH (c:case {case_id: $case_id})<-[*]-(s:sample) RETURN count(distinct(s))")

    programCountOfStudy(study_code: String!): Int @cypher(statement: "MATCH (s:study {clinical_study_designation: $study_code}) OPTIONAL MATCH (s)-[:member_of]->(p: program)  return count(DISTINCT(p))")
    programsCountOfCase(case_id: String!): Int @cypher(statement: "MATCH (c:case {case_id: $case_id}) OPTIONAL MATCH (c)-[:member_of]->(s:study) OPTIONAL MATCH (s)-[:member_of]->(p:program) return count(DISTINCT(p))")

    filesInList(uuids: [String], order_by: String = ""): [FileInList] @cypher(statement: """
    MATCH (f:file)
    WHERE f.uuid in $uuids
    OPTIONAL MATCH (f)-->(parent)
    OPTIONAL MATCH (f)-[*]->(samp:sample)
    OPTIONAL MATCH (f:file)-[*]->(c:case)
    OPTIONAL MATCH (diag:diagnosis)-[:of_case]->(c)
    OPTIONAL MATCH (demo:demographic)-[:of_case]->(c)
    OPTIONAL MATCH (enroll:enrollment)-[:of_case]->(c)
    OPTIONAL MATCH (samp:sample)-[:of_case]->(c)
    OPTIONAL MATCH (s:study)<-[:member_of]-(c)
    OPTIONAL MATCH (c)-->(i:canine_individual)<--(o:case)
    OPTIONAL MATCH (c)-->(co:cohort)
    OPTIONAL MATCH (co)-->(a:study_arm)
    WITH
    f.file_name AS file_name,
    f.file_type AS file_type,
    head(labels(parent)) AS association,
    f.file_description AS file_description,
    f.file_format AS file_format,
    f.file_size AS file_size,
    c.case_id as case_id,
    demo.breed as breed,
    diag.disease_term as diagnosis,
    CASE WHEN s.clinical_study_designation IS NULL
    THEN parent.clinical_study_designation
    ELSE s.clinical_study_designation END AS study_code,
    f.uuid as file_uuid,
    f.md5sum AS md5sum,
    samp.sample_id AS sample_id,
    i.canine_individual_id AS individual_id,
    samp.sample_site as sample_site,
    samp.physical_sample_type as physical_sample_type,
    samp.general_sample_pathology as general_sample_pathology,
    samp.tumor_sample_origin as tumor_sample_origin,
    samp.summarized_sample_type as summarized_sample_type,
    samp.specific_sample_pathology as specific_sample_pathology,
    samp.date_of_sample_collection as date_of_sample_collection,
    samp.tumor_grade as tumor_grade,
    samp.sample_chronology as sample_chronology,
    samp.percentage_tumor as percentage_tumor,
    samp.necropsy_sample as necropsy_sample,
    samp.sample_preservation as sample_preservation,
    samp.comment as comment,
    demo.patient_age_at_enrollment as patient_age_at_enrollment,
    demo.sex as sex,
    demo.neutered_indicator as neutered_indicator,
    demo.weight as weight,
    demo.weight_unit as weight_unit,
    diag.disease_term as disease_term,
    diag.primary_disease_site as primary_disease_site,
    diag.stage_of_disease as stage_of_disease,
    diag.date_of_diagnosis as date_of_diagnosis,
    diag.histology_cytopathology as histology_cytopathology,
    diag.histological_grade as histological_grade,
    diag.best_response as best_response,
    diag.pathology_report as pathology_report,
    diag.treatment_data as treatment_data,
    diag.follow_up_data as follow_up_data,
    diag.concurrent_disease as concurrent_disease,
    diag.concurrent_disease_type as concurrent_disease_type,
    co.cohort_description as cohort_description,
    a.arm as arm,
    collect(DISTINCT o.case_id) AS other_cases
    RETURN{
    file_name: file_name,
    file_type: file_type,
    association: association,
    file_description: file_description,
    file_format: file_format,
    file_size: file_size,
    case_id: case_id,
    breed: breed,
    diagnosis: diagnosis,
    study_code: study_code,
    file_uuid: file_uuid,
    md5sum: md5sum,
    sample_id: sample_id,
    individual_id: individual_id,
    sample_site: sample_site,
    physical_sample_type: physical_sample_type,
    general_sample_pathology: general_sample_pathology,
    tumor_sample_origin: tumor_sample_origin,
    summarized_sample_type: summarized_sample_type,
    specific_sample_pathology: specific_sample_pathology,
    date_of_sample_collection: date_of_sample_collection,
    tumor_grade: tumor_grade,
    sample_chronology: sample_chronology,
    percentage_tumor: percentage_tumor,
    necropsy_sample: necropsy_sample,
    sample_preservation: sample_preservation,
    comment: comment,
    patient_age_at_enrollment: patient_age_at_enrollment,
    sex: sex,
    neutered_indicator: neutered_indicator,
    weight: weight,
    weight_unit: weight_unit,
    disease_term: disease_term,
    primary_disease_site: primary_disease_site,
    stage_of_disease: stage_of_disease,
    date_of_diagnosis: date_of_diagnosis,
    histology_cytopathology: histology_cytopathology,
    histological_grade: histological_grade,
    best_response: best_response,
    pathology_report: pathology_report,
    treatment_data: treatment_data,
    follow_up_data: follow_up_data,
    concurrent_disease: concurrent_disease,
    concurrent_disease_type: concurrent_disease_type,
    cohort_description: cohort_description,
    arm: arm,
    other_cases: other_cases
    }
    ORDER BY CASE $order_by
    WHEN 'file_name' THEN file_name
    WHEN 'file_type' THEN file_type
    WHEN 'association' THEN association
    WHEN 'file_description' THEN file_description
    WHEN 'file_format' THEN file_format
    WHEN 'file_size' THEN file_size
    WHEN 'case_id' THEN case_id
    WHEN 'breed' THEN breed
    WHEN 'diagnosis' THEN diagnosis
    WHEN 'study_code' THEN study_code
    WHEN 'file_uuid' THEN file_uuid
    WHEN 'md5sum' THEN md5sum
    WHEN 'individual_id' THEN individual_id
    WHEN 'access_file' THEN (CASE file_size < 12000000 WHEN TRUE THEN 0 ELSE 1 END)
    ELSE file_uuid END
    """, passThrough: true)

    filesInListDesc(uuids: [String], order_by: String = ""): [FileInList] @cypher(statement: """
    MATCH (f:file)
    WHERE f.uuid in $uuids
    OPTIONAL MATCH (f)-->(parent)
    OPTIONAL MATCH (f)-[*]->(samp:sample)
    OPTIONAL MATCH (f:file)-[*]->(c:case)
    OPTIONAL MATCH (diag:diagnosis)-[:of_case]->(c)
    OPTIONAL MATCH (demo:demographic)-[:of_case]->(c)
    OPTIONAL MATCH (enroll:enrollment)-[:of_case]->(c)
    OPTIONAL MATCH (samp:sample)-[:of_case]->(c)
    OPTIONAL MATCH (s:study)<-[:member_of]-(c)
    OPTIONAL MATCH (c)-->(i:canine_individual)<--(o:case)
    OPTIONAL MATCH (c)-->(co:cohort)
    OPTIONAL MATCH (co)-->(a:study_arm)
    WITH
    f.file_name AS file_name,
    f.file_type AS file_type,
    head(labels(parent)) AS association,
    f.file_description AS file_description,
    f.file_format AS file_format,
    f.file_size AS file_size,
    c.case_id as case_id,
    demo.breed as breed,
    diag.disease_term as diagnosis,
    CASE WHEN s.clinical_study_designation IS NULL
    THEN parent.clinical_study_designation
    ELSE s.clinical_study_designation END AS study_code,
    f.uuid as file_uuid,
    f.md5sum AS md5sum,
    samp.sample_id AS sample_id,
    i.canine_individual_id AS individual_id,
    samp.sample_site as sample_site,
    samp.physical_sample_type as physical_sample_type,
    samp.general_sample_pathology as general_sample_pathology,
    samp.tumor_sample_origin as tumor_sample_origin,
    samp.summarized_sample_type as summarized_sample_type,
    samp.specific_sample_pathology as specific_sample_pathology,
    samp.date_of_sample_collection as date_of_sample_collection,
    samp.tumor_grade as tumor_grade,
    samp.sample_chronology as sample_chronology,
    samp.percentage_tumor as percentage_tumor,
    samp.necropsy_sample as necropsy_sample,
    samp.sample_preservation as sample_preservation,
    samp.comment as comment,
    demo.patient_age_at_enrollment as patient_age_at_enrollment,
    demo.sex as sex,
    demo.neutered_indicator as neutered_indicator,
    demo.weight as weight,
    demo.weight_unit as weight_unit,
    diag.disease_term as disease_term,
    diag.primary_disease_site as primary_disease_site,
    diag.stage_of_disease as stage_of_disease,
    diag.date_of_diagnosis as date_of_diagnosis,
    diag.histology_cytopathology as histology_cytopathology,
    diag.histological_grade as histological_grade,
    diag.best_response as best_response,
    diag.pathology_report as pathology_report,
    diag.treatment_data as treatment_data,
    diag.follow_up_data as follow_up_data,
    diag.concurrent_disease as concurrent_disease,
    diag.concurrent_disease_type as concurrent_disease_type,
    co.cohort_description as cohort_description,
    a.arm as arm,
    collect(DISTINCT o.case_id) AS other_cases
    RETURN{
    file_name: file_name,
    file_type: file_type,
    association: association,
    file_description: file_description,
    file_format: file_format,
    file_size: file_size,
    case_id: case_id,
    breed: breed,
    diagnosis: diagnosis,
    study_code: study_code,
    file_uuid: file_uuid,
    md5sum: md5sum,
    sample_id: sample_id,
    individual_id: individual_id,
    sample_site: sample_site,
    physical_sample_type: physical_sample_type,
    general_sample_pathology: general_sample_pathology,
    tumor_sample_origin: tumor_sample_origin,
    summarized_sample_type: summarized_sample_type,
    specific_sample_pathology: specific_sample_pathology,
    date_of_sample_collection: date_of_sample_collection,
    tumor_grade: tumor_grade,
    sample_chronology: sample_chronology,
    percentage_tumor: percentage_tumor,
    necropsy_sample: necropsy_sample,
    sample_preservation: sample_preservation,
    comment: comment,
    patient_age_at_enrollment: patient_age_at_enrollment,
    sex: sex,
    neutered_indicator: neutered_indicator,
    weight: weight,
    weight_unit: weight_unit,
    disease_term: disease_term,
    primary_disease_site: primary_disease_site,
    stage_of_disease: stage_of_disease,
    date_of_diagnosis: date_of_diagnosis,
    histology_cytopathology: histology_cytopathology,
    histological_grade: histological_grade,
    best_response: best_response,
    pathology_report: pathology_report,
    treatment_data: treatment_data,
    follow_up_data: follow_up_data,
    concurrent_disease: concurrent_disease,
    concurrent_disease_type: concurrent_disease_type,
    cohort_description: cohort_description,
    arm: arm,
    other_cases: other_cases
    }
    ORDER BY CASE $order_by
    WHEN 'file_name' THEN file_name
    WHEN 'file_type' THEN file_type
    WHEN 'association' THEN association
    WHEN 'file_description' THEN file_description
    WHEN 'file_format' THEN file_format
    WHEN 'file_size' THEN file_size
    WHEN 'case_id' THEN case_id
    WHEN 'breed' THEN breed
    WHEN 'diagnosis' THEN diagnosis
    WHEN 'study_code' THEN study_code
    WHEN 'file_uuid' THEN file_uuid
    WHEN 'md5sum' THEN md5sum
    WHEN 'individual_id' THEN individual_id
    WHEN 'access_file' THEN (CASE file_size > 12000000 WHEN TRUE THEN 1 ELSE 0 END)
    ELSE file_uuid END DESC
    """, passThrough: true)

    "Combined info"
    studiesByProgramId(program_id: String!): [StudyOfProgram] @cypher(statement: """
    MATCH (p:program {program_acronym: $program_id})<-[*]-(s:study)
    OPTIONAL MATCH (s)<-[*]-(c:case)
    OPTIONAL MATCH (s)<--(sf:file)
    OPTIONAL MATCH (s)<--(ic:image_collection)
    OPTIONAL MATCH (s)<--(pub:publication)
    OPTIONAL MATCH (c)<-[*]-(cf:file)
    WITH p, s,
    COUNT(DISTINCT sf) AS numberOfStudyFiles,
    COUNT(DISTINCT cf) AS numberOfCaseFiles,
    COUNT(DISTINCT ic) AS numberOfImageCollections,
    COUNT(DISTINCT ic.repository_name) AS numberOfCRDCNodes,
    COUNT(DISTINCT pub) AS numberOfPublications,
    COUNT(DISTINCT(c)) AS numberOfCases,
    COLLECT(DISTINCT ic{text: ic.image_collection_name + ' - ' + ic.repository_name,
    url: ic.image_collection_url}) AS CRDCLinks
    RETURN{
    program_id: p.program_acronym,
    clinical_study_id: s.clinical_study_id,
    clinical_study_designation: s.clinical_study_designation,
    clinical_study_name: s.clinical_study_name,
    clinical_study_description: s.clinical_study_description,
    clinical_study_type: s.clinical_study_type,
    accession_id: s.accession_id,
    study_disposition: s.study_disposition,
    date_of_iacuc_approval: s.date_of_iacuc_approval,
    dates_of_conduct: s.dates_of_conduct,
    numberOfCases: numberOfCases,
    numberOfStudyFiles: numberOfStudyFiles,
    numberOfCaseFiles: numberOfCaseFiles,
    numberOfImageCollections: numberOfImageCollections,
    numberOfPublications: numberOfPublications,
    numberOfCRDCNodes: numberOfCRDCNodes,
    CRDCLinks: CRDCLinks
    }
    ORDER BY s.clinical_study_designation
    """, passThrough: true)

    studiesByProgram: [StudyOfProgram] @cypher(statement:"""
    MATCH (s:study)
    OPTIONAL MATCH (p:program)<-[*]-(s)
    OPTIONAL MATCH (s)<-[*]-(c:case)
    OPTIONAL MATCH (s)<--(sf:file)
    OPTIONAL MATCH (s)<--(ic:image_collection)
    OPTIONAL MATCH (s)<--(pub:publication)
    OPTIONAL MATCH (c)<-[*]-(cf:file)
    WITH p, s,
    COUNT(DISTINCT sf) AS numberOfStudyFiles,
    COUNT(DISTINCT cf) AS numberOfCaseFiles,
    COUNT(DISTINCT ic) AS numberOfImageCollections,
    COUNT(DISTINCT ic.repository_name) AS numberOfCRDCNodes,
    COUNT(DISTINCT pub) AS numberOfPublications,
    COUNT(DISTINCT(c)) AS numberOfCases,
    COLLECT(DISTINCT ic{text: ic.image_collection_name + ' - ' + ic.repository_name,
    url: ic.image_collection_url}) AS CRDCLinks
    RETURN{
    program_id: p.program_acronym,
    clinical_study_id: s.clinical_study_id,
    clinical_study_designation: s.clinical_study_designation,
    clinical_study_name: s.clinical_study_name,
    clinical_study_description: s.clinical_study_description,
    clinical_study_type: s.clinical_study_type,
    accession_id: s.accession_id,
    study_disposition: s.study_disposition,
    date_of_iacuc_approval: s.date_of_iacuc_approval,
    dates_of_conduct: s.dates_of_conduct,
    numberOfCases: numberOfCases,
    numberOfStudyFiles: numberOfStudyFiles,
    numberOfCaseFiles: numberOfCaseFiles,
    numberOfImageCollections: numberOfImageCollections,
    numberOfPublications: numberOfPublications,
    numberOfCRDCNodes: numberOfCRDCNodes,
    CRDCLinks: CRDCLinks
    }
    ORDER BY s.clinical_study_designation
    """, passThrough: true)

    filesOfCase(case_id: String!): [FilesOfCase] @cypher(statement: """
    MATCH (f:file)-[*]->(c:case{case_id: $case_id})
    WITH DISTINCT(f) AS f
    MATCH (f)-->(parent)
    RETURN{
    file_status: f.file_status,
    file_name: f.file_name,
    file_type: f.file_type,
    file_description: f.file_description,
    file_format: f.file_format,
    file_size: f.file_size,
    md5sum: f.md5sum,
    uuid: f.uuid,
    file_location: f.file_location,
    parent: head(labels(parent)),
    case_id: $case_id
    }
    """, passThrough: true)

    filesOfCases(case_ids: [String!]!): [FilesOfCase] @cypher(statement: """
    MATCH (f:file)-[*]->(c:case)
    WITH
    DISTINCT(f) AS f,
    c MATCH (f)-->(parent)
    WHERE c.case_id IN $case_ids
    RETURN{
    file_status: f.file_status,
    file_name: f.file_name,
    file_type: f.file_type,
    file_description: f.file_description,
    file_format: f.file_format,
    file_size: f.file_size,
    md5sum: f.md5sum,
    uuid: f.uuid,
    file_location: f.file_location,
    parent: head(labels(parent)),
    case_id: c.case_id
    }
    """, passThrough: true)

    multiStudyCases(case_id: String): MultiStudyCases @cypher(statement: """
    MATCH (:case {case_id: $case_id})-->(i:canine_individual)
    MATCH (i)<--(c:case)
    OPTIONAL MATCH (c)<--(samp:sample)
    OPTIONAL MATCH (c)<-[*]-(f:file)
    OPTIONAL MATCH (c) -[:member_of]->(s:study)
    OPTIONAL MATCH (sf:file)-->(s)
    WITH i, c, f, samp, sf
    RETURN{
    individualId: i.canine_individual_id,
    caseIds: collect(DISTINCT c.case_id),
    sampleIds: collect(DISTINCT samp.sample_id),
    fileIds: collect(DISTINCT f.uuid),
    studyFileIds: collect(DISTINCT sf.uuid)
    }
    """, passThrough: true)

    caseDetail(case_id: String): CaseDetail @cypher(statement: """
    MATCH (c:case {case_id: $case_id})-->(s:study)-->(p:program)
    OPTIONAL MATCH (c)-->(co:cohort)-->(a:study_arm)
    OPTIONAL MATCH (c)<--(demo:demographic)
    OPTIONAL MATCH (c)<--(diag:diagnosis)
    OPTIONAL MATCH (c)<--(e:enrollment)
    RETURN{
    program_acronym: p.program_acronym,
    clinical_study_name: s.clinical_study_name,
    clinical_study_designation: s.clinical_study_designation,
    arm: a.arm,
    ctep_treatment_assignment_code: a.ctep_treatment_assignment_code,
    cohort_description: co.cohort_description,
    case_id: c.case_id,
    patient_id: c.patient_id,
    patient_first_name: c.patient_first_name,
    breed: demo.breed,
    sex: demo.sex,
    patient_age_at_enrollment: demo.patient_age_at_enrollment,
    neutered_indicator: demo.neutered_indicator,
    weight: demo.weight,
    site_short_name: e.site_short_name,
    date_of_registration: e.date_of_registration,
    patient_subgroup: e.patient_subgroup,
    date_of_informed_consent: e.date_of_informed_consent,
    initials: e.initials,
    disease_term: diag.disease_term,
    stage_of_disease: diag.stage_of_disease,
    best_response: diag.best_response,
    date_of_diagnosis: diag.date_of_diagnosis,
    primary_disease_site: diag.primary_disease_site,
    histological_grade: diag.histological_grade,
    histology_cytopathology: diag.histology_cytopathology
    }
    """, passThrough: true)

    caseOverview(study_codes: [String] = [""], breeds: [String] = [""], diagnoses: [String] = [""], sexes: [String] = [""]): [CaseOverview] @cypher(statement: """
    MATCH (s:study)
    WITH collect(DISTINCT(s.clinical_study_designation)) AS all_studies
    MATCH (d:demographic)
    WITH collect(DISTINCT(d.breed)) AS all_breeds, collect(DISTINCT(d.sex)) AS all_sexes, all_studies
    MATCH (d:diagnosis)
    WITH collect(DISTINCT(d.disease_term)) AS all_diseases, all_breeds, all_sexes, all_studies
    MATCH (p:program)<-[*]-(s:study)<-[*]-(c:case)<--(demo:demographic), (c)<--(diag:diagnosis)
    WHERE
    s.clinical_study_designation IN
    CASE
    WHEN ($study_codes = [""] OR $study_codes IS NULL)
    THEN all_studies
    ELSE $study_codes
    END
    AND
    demo.breed IN
    CASE
    WHEN ($breeds = [""] OR $breeds IS NULL)
    THEN all_breeds
    ELSE $breeds
    END
    AND
    diag.disease_term IN
    CASE
    WHEN ($diagnoses = [""] OR $diagnoses IS NULL)
    THEN all_diseases
    ELSE $diagnoses
    END
    AND
    demo.sex IN
    CASE
    WHEN ($sexes = [""] OR $sexes IS NULL)
    THEN all_sexes
    ELSE $sexes
    END
    OPTIONAL MATCH (f:file)-[*]->(c)
    OPTIONAL MATCH (f)-->(prt)
    OPTIONAL MATCH (samp:sample)-[*]->(c)
    WITH DISTINCT c AS c, p, s, demo, diag, f, samp, prt
    RETURN{
    case_id: c.case_id,
    study_code: s.clinical_study_designation,
    program: p.program_acronym,
    study_type: s.clinical_study_type,
    breed: demo.breed,
    diagnosis: diag.disease_term,
    stage_of_disease: diag.stage_of_disease,
    disease_site: diag.primary_disease_site,
    age: demo.patient_age_at_enrollment,
    sex: demo.sex,
    neutered_status: demo.neutered_indicator,
    data_types: collect(DISTINCT(f.file_type)),
    file_formats: collect(DISTINCT(f.file_format)),
    files: collect(DISTINCT(f {parent:labels(prt)[0], .file_name, .file_name, .file_type, .file_description, .file_format, .file_size, .md5sum, .file_status, .uuid, .file_location})),
    samples: collect(DISTINCT(samp.sample_id)),
    sample_list: collect(DISTINCT(samp{.*})),
    demographic: demo,
    diagnosis_obj: diag
    }
    """, passThrough: true)

    casesInList(case_ids: [String!]!): [CaseOverview] @cypher(statement: """
    MATCH
    (p:program)<-[*]-(s:study)<-[*]-(c:case)<--(demo:demographic),
    (c)<--(diag:diagnosis)
    WHERE c.case_id IN $case_ids
    OPTIONAL MATCH (f:file)-[*]->(c)
    OPTIONAL MATCH (samp:sample)-[*]->(c)
    WITH DISTINCT c AS c, p, s, demo, diag, f, samp
    RETURN{
    case_id: c.case_id,
    study_code: s.clinical_study_designation,
    program: p.program_acronym,
    study_type: s.clinical_study_type,
    breed: demo.breed,
    diagnosis: diag.disease_term,
    stage_of_disease: diag.stage_of_disease,
    disease_site: diag.primary_disease_site,
    age: demo.patient_age_at_enrollment,
    sex: demo.sex,
    neutered_status: demo.neutered_indicator,
    data_types: collect(DISTINCT(f.file_type)),
    file_formats: collect(DISTINCT(f.file_format)),
    files: collect(DISTINCT(f{.*})),
    samples: collect(DISTINCT(samp.sample_id)),
    sample_list: collect(DISTINCT(samp{.*}))
    }
    """, passThrough:true)

    studyDetail(study_code: String!): [StudyDetail] @cypher(statement: """
    MATCH (s:study {clinical_study_designation: $study_code})<-[*]-(p)<--(f:file)
    WITH DISTINCT(f), s, p
    RETURN{
    study_code: s.clinical_study_designation,
    file_name: f.file_name,
    file_type: f.file_type,
    association: head(labels(p)),
    description: f.file_description,
    format: f.file_format,
    size: f.file_size,
    MD5: f.md5sum
    }
    """, passThrough: true)

    "Find nodes with parameters"
    casesByStudyId(study_id: String!): [case] @cypher(statement: """
    MATCH (s:study {clinical_study_designation: $study_id})<-[*]-(c:case)
    RETURN DISTINCT(c)
    """)

    samplesByCaseId(case_id: String!): [sample] @cypher(statement: """
    MATCH (c:case {case_id: $case_id})<-[*]-(s:sample)
    RETURN s
    """)

    filesBySampleId(sample_id: String!): [file] @cypher(statement: """
    MATCH (s:sample {sample_id: $sample_id})<-[*]-(f:file)
    RETURN f
    """)

    filesOfStudy(study_code: String!): [file] @cypher(statement: """
    MATCH (f:file)-[*]->(sd:study) WHERE sd.clinical_study_designation = $study_code OR sd.accession_id = $study_code
    RETURN DISTINCT(f)
    """)

    studyFiles(study_codes: [String!]): [file] @cypher(statement: """
    MATCH (s:study)<--(f:file)
    WHERE s.clinical_study_designation IN $study_codes OR s.accession_id IN $study_codes
    RETURN f{.*}
    """, passThrough: true)

    "For SBG to replace manifest"
    fileDetail(file_ids: [String] = []): [FileDetail] @cypher(statement: """
    MATCH (f:file)
    WITH collect(f.uuid) AS all_files
    MATCH (f:file)-[*]->(s:study)
    WHERE f.uuid IN CASE $file_ids WHEN [] THEN all_files
    ELSE $file_ids
    END
    OPTIONAL MATCH (f)-[*]->(c:case)
    OPTIONAL MATCH (f)-[*]->(co:cohort)
    OPTIONAL MATCH (f)-[*]->(arm:study_arm)
    OPTIONAL MATCH (demo:demographic)-->(c)
    OPTIONAL MATCH (diag:diagnosis)-->(c)
    OPTIONAL MATCH (f)-[*]->(v:visit)
    OPTIONAL MATCH (f)-->(samp:sample)
    WITH DISTINCT (f) AS f, s, c, co, arm, demo, diag, v, samp,
    f.file_type as file_type,
    c.case_id as case_id
    RETURN{
    clinical_study_designation: s.clinical_study_designation,
    clinical_study_name: s.clinical_study_name,
    arm: arm.arm,
    cohort_description: co.cohort_description,
    cohort_dose: co.cohort_dose,
    case_id: case_id,
    breed: demo.breed,
    weight: demo.weight,
    sex: demo.sex,
    neutered_indicator: demo.neutered_indicator,
    patient_age_at_enrollment: demo.patient_age_at_enrollment,
    disease_term: diag.disease_term,
    stage_of_disease: diag.stage_of_disease,
    primary_disease_site: diag.primary_disease_site,
    concurrent_disease: diag.concurrent_disease,
    concurrent_disease_type: diag.concurrent_disease_type,
    visit_date: v.visit_date,
    visit_number: v.visit_number,
    day_in_cycle: v.day_in_cycle,
    sample_id: samp.sample_id,
    sample_type: samp.physical_sample_type,
    general_sample_pathology: samp.general_sample_pathology,
    specific_sample_pathology: samp.specific_sample_pathology,
    sample_site: samp.sample_site,
    date_of_sample_collection: samp.date_of_sample_collection,
    necropsy_sample: samp.necropsy_sample,
    percentage_tumor: samp.percentage_tumor,
    percentage_stroma: samp.percentage_stroma,
    comment: samp.comment,
    file_name: f.file_name,
    file_type: file_type,
    file_description: f.file_description,
    file_format: f.file_format,
    file_size: f.file_size,
    md5sum: f.md5sum,
    file_location: f.file_location,
    uuid: f.uuid,
    acl: f.acl,
    GUID: 'dg.4DFC/' + f.uuid,
    md5: f.md5sum,
    size: f.file_size,
    url: f.file_location
    }
    ORDER BY file_type, case_id
    """, passThrough: true)

    "For IndexD to replace manifest"
    fileInfo(file_ids: [String] = []): [FileInfo] @cypher(statement: """
    MATCH (f:file)
    WITH collect(f.uuid) as all_files
    MATCH (f:file)
    WHERE f.uuid IN CASE $file_ids WHEN [] THEN all_files ELSE $file_ids END
    WITH f, f.file_location as url
    RETURN{
    GUID: 'dg.4DFC/' + f.uuid,
    md5: f.md5sum,
    size: f.file_size,
    acl: f.acl,
    url: f.file_location
    }
    ORDER BY url
    """, passThrough: true)

    studyStats: [StudyStat] @cypher(statement: """
    MATCH (s:study)
    OPTIONAL MATCH (s)<-[*]-(c:case)
    WITH s, COUNT(DISTINCT c) AS cases
    OPTIONAL MATCH (s)<-[*]-(samp:sample)
    WITH s, cases, COUNT(DISTINCT samp) AS samples
    OPTIONAL MATCH (s)<-[*]-(f:file)
    WITH DISTINCT f, s, cases, samples
    RETURN{
    study_code: s.clinical_study_designation,
    files: COUNT(f),
    total_size_MB: SUM(f.file_size)/1000000,
    cases: cases,
    samples: samples
    }
    """, passThrough: true)

    fileIdsFromFileName(file_name: [String] = [""], order_by: String ="file_name"): [FileOverview] @cypher(statement: """
    MATCH (f:file)
    WHERE ($file_name = [""] OR $file_name IS NULL OR f.file_name IN $file_name)
    WITH
    f.file_name AS file_name,
    f.uuid AS file_uuid
    RETURN{
    file_name: file_name,
    file_uuid: file_uuid
    }
    ORDER BY CASE $order_by
    WHEN 'file_name' THEN file_name
    WHEN 'file_uuid' THEN file_uuid
    ELSE file_name END
    """, passThrough: true)

    fileIdsFromFileNameDesc(file_name: [String] = [""], order_by: String ="file_name"): [FileOverview] @cypher(statement: """
    MATCH (f:file)
    WHERE ($file_name = [""] OR $file_name IS NULL OR f.file_name IN $file_name)
    WITH
    f.file_name AS file_name,
    f.uuid AS file_uuid
    RETURN{
    file_name: file_name,
    file_uuid: file_uuid
    }
    ORDER BY CASE $order_by
    WHEN 'file_name' THEN file_name
    WHEN 'file_uuid' THEN file_uuid
    ELSE file_name END DESC
    """, passThrough: true)

    unifiedViewData(case_ids: [String] = [""]): UnifiedCounts @cypher(statement: """
    MATCH (c:case)
    WHERE ($case_ids = [""] OR $case_ids IS NULL OR c.case_id IN $case_ids)
    OPTIONAL MATCH (s:study)<--(c)
    OPTIONAL MATCH (f:file)-[*]->(c)
    OPTIONAL MATCH (samp:sample)-->(c)
    OPTIONAL MATCH (a:aliquot)-[*]->(c)
    OPTIONAL MATCH (c)-[:member_of]->(sd:study)
    OPTIONAL MATCH (sf:file)-->(sd)
    OPTIONAL MATCH (s)-[:member_of]->(p: program)
    WITH a, s, c, f, samp, sf, p
    RETURN{
    numberOfStudies: COUNT(DISTINCT s),
    numberOfCases: COUNT(DISTINCT c),
    numberOfFiles: COUNT(DISTINCT f) + COUNT(DISTINCT sf),
    numberOfSamples: COUNT(DISTINCT samp),
    numberOfAliquots: COUNT(DISTINCT a),
    numberOfStudyFiles: COUNT(DISTINCT sf),
    numberOfPrograms: COUNT(DISTINCT p),
    volumeOfData: SUM(f.file_size)
    }
    """, passThrough: true)

    studySampleSiteCount(study_codes: [String]): [GroupCount] @cypher(statement: """
    MATCH (s:study)
    WHERE s.clinical_study_designation in $study_codes OR s.accession_id in $study_codes
    OPTIONAL MATCH (c:case) --> (s)
    OPTIONAL MATCH (c) <-- (samp: sample)
    WITH DISTINCT(samp.sample_site) AS group, COUNT(DISTINCT samp) AS counts where counts > 0
    RETURN {
    group: group,
    count: counts
    }
    ORDER BY group
    """, passThrough: true)

    studySampleTypeCount(study_codes: [String]): [GroupCount] @cypher(statement: """
    MATCH (s:study)
    WHERE s.clinical_study_designation in $study_codes OR s.accession_id in $study_codes
    OPTIONAL MATCH (c:case) --> (s)
    OPTIONAL MATCH (c) <-- (samp: sample)
    WITH DISTINCT(samp.summarized_sample_type) AS group, COUNT(DISTINCT samp) AS counts where counts > 0
    RETURN {
    group: group,
    count: counts
    }
    ORDER BY group
    """, passThrough: true)

    studySamplePathologyCount(study_codes: [String]): [GroupCount] @cypher(statement: """
    MATCH (s:study)
    WHERE s.clinical_study_designation in $study_codes OR s.accession_id in $study_codes
    OPTIONAL MATCH (c:case) --> (s)
    OPTIONAL MATCH (c) <-- (samp: sample)
    WITH DISTINCT(samp.specific_sample_pathology) AS group, COUNT(DISTINCT samp) AS counts where counts > 0
    RETURN {
    group: group,
    count: counts
    }
    ORDER BY group
    """, passThrough: true)
}

